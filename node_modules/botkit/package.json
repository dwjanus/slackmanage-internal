{
  "_args": [
    [
      {
        "raw": "botkit@github:howdyai/botkit",
        "scope": null,
        "escapedName": "botkit",
        "name": "botkit",
        "rawSpec": "github:howdyai/botkit",
        "spec": "github:howdyai/botkit",
        "type": "hosted",
        "hosted": {
          "type": "github",
          "ssh": "git@github.com:howdyai/botkit.git",
          "sshUrl": "git+ssh://git@github.com/howdyai/botkit.git",
          "httpsUrl": "git+https://github.com/howdyai/botkit.git",
          "gitUrl": "git://github.com/howdyai/botkit.git",
          "shortcut": "github:howdyai/botkit",
          "directUrl": "https://raw.githubusercontent.com/howdyai/botkit/master/package.json"
        }
      },
      "/Users/devinjanus/slackmanage-internal"
    ]
  ],
  "_from": "howdyai/botkit",
  "_id": "botkit@0.4.6",
  "_inCache": true,
  "_location": "/botkit",
  "_phantomChildren": {},
  "_requested": {
    "raw": "botkit@github:howdyai/botkit",
    "scope": null,
    "escapedName": "botkit",
    "name": "botkit",
    "rawSpec": "github:howdyai/botkit",
    "spec": "github:howdyai/botkit",
    "type": "hosted",
    "hosted": {
      "type": "github",
      "ssh": "git@github.com:howdyai/botkit.git",
      "sshUrl": "git+ssh://git@github.com/howdyai/botkit.git",
      "httpsUrl": "git+https://github.com/howdyai/botkit.git",
      "gitUrl": "git://github.com/howdyai/botkit.git",
      "shortcut": "github:howdyai/botkit",
      "directUrl": "https://raw.githubusercontent.com/howdyai/botkit/master/package.json"
    }
  },
  "_requiredBy": [
    "/"
  ],
  "_resolved": "git://github.com/howdyai/botkit.git#7d2c2da1d7665778e247a28d2172f83ba57aa36e",
  "_shasum": "027b1067b277113b5acfae028e8cf774d71f79e5",
  "_shrinkwrap": null,
  "_spec": "botkit@github:howdyai/botkit",
  "_where": "/Users/devinjanus/slackmanage-internal",
  "author": {
    "name": "ben@xoxco.com"
  },
  "bugs": {
    "url": "https://github.com/howdyai/botkit/issues"
  },
  "dependencies": {
    "async": "^2.0.0-rc.5",
    "back": "^1.0.1",
    "body-parser": "^1.14.2",
    "botbuilder": "^3.2.3",
    "botkit-studio-sdk": "^1.0.0",
    "clone": "2.0.0",
    "command-line-args": "^3.0.0",
    "crypto": "0.0.3",
    "express": "^4.13.3",
    "https-proxy-agent": "^1.0.0",
    "jfs": "^0.2.6",
    "localtunnel": "^1.8.1",
    "md5": "^2.1.0",
    "mustache": "^2.2.1",
    "promise": "^7.1.1",
    "randomstring": "^1.1.5",
    "request": "^2.67.0",
    "twilio": "^2.9.1",
    "ware": "^1.3.0",
    "ws": "^1.1.1"
  },
  "description": "Building blocks for Building Bots",
  "devDependencies": {
    "jscs": "^2.7.0",
    "mocha": "^2.4.5",
    "should": "^8.0.2",
    "winston": "^2.1.1"
  },
  "gitHead": "7d2c2da1d7665778e247a28d2172f83ba57aa36e",
  "homepage": "http://howdy.ai/botkit",
  "keywords": [
    "bots",
    "chatbots",
    "slack",
    "facebook messenger",
    "twilio ipm",
    "microsoft bot framework"
  ],
  "license": "MIT",
  "main": "lib/Botkit.js",
  "name": "botkit",
  "optionalDependencies": {},
  "readme": "# [Botkit](http://howdy.ai/botkit) - Building Blocks for Building Bots\n\n[![npm](https://img.shields.io/npm/v/botkit.svg)](https://www.npmjs.com/package/botkit)\n[![David](https://img.shields.io/david/howdyai/botkit.svg)](https://david-dm.org/howdyai/botkit)\n[![npm](https://img.shields.io/npm/l/botkit.svg)](https://spdx.org/licenses/MIT)\n\nBotkit is designed to ease the process of designing and running useful, creative bots that live inside [Slack](http://slack.com), [Facebook Messenger](http://facebook.com), [Twilio IP Messaging](https://www.twilio.com/docs/api/ip-messaging), and other messaging platforms. Support for new platforms is added regularly!\n\nIt provides a semantic interface to sending and receiving messages so that developers can focus on creating novel applications and experiences instead of dealing with API endpoints.\n\nBotkit features a comprehensive set of tools to deal with popular messaging platforms, including:\n\n* [Slack](readme-slack.md)\n* [Facebook Messenger](readme-facebook.md)\n* [Twilio IP Messaging](readme-twilioipm.md)\n* [Microsoft Bot Framework](readme-botframework.md)\n* Yours? [info@howdy.ai](mailto:info@howdy.ai)\n\n## Botkit Studio\n\n[Botkit Studio](https://studio.botkit.ai) is a hosted development environment for bots from the same team that built Botkit.\nBased on feedback from the developer community, as well as experience running our flagship Botkit-powered bot, [Howdy](http://howdy.ai),\nthe tools in Botkit Studio allow bot designers and developers to manage many aspects of bot behavior without writing additional code.\n\n[Start building your bot with Botkit Studio](readme-studio.md) and you'll start from day one with extra tools and features that\nhelp you create and manage a successful bot application. It is also possible to add Studio features to your existing Botkit application. [With a few lines of code](readme-studio.md#adding-studio-features-to-an-existing-bot), you can add access new features and APIs.\n\nBotkit Studio is built on top of Botkit, so everything that works with Botkit continues to just work. All of the available plugins and middleware are compatible!\n\n## Getting Started\n\nThere are two ways to start a Botkit project:\n\n1) [Install the Botkit Studio Starter Kit](https://github.com/howdyai/botkit-studio-starter) and build on top of an already fully functioning bot\nthat comes pre-configured with popular middleware plug-ins and components.\n\n2) [Install Botkit directly from NPM or Github](#install-botkit-from-npm-or-github) and build a new app from scratch, or use one of the [included examples](#included-examples) as a starting point.\n\nAfter you've installed Botkit using one of these methods, the first thing you'll need to do is register your bot with a messaging platform, and get a few configuration options set. This will allow your bot to connect, send and receive messages.\n\nIf you intend to create a bot that\nlives in Slack, [follow these instructions for attaining a Bot Token](readme-slack.md#getting-started).\n\nIf you intend to create a bot that lives in Facebook Messenger, [follow these instructions for configuring your Facebook page](readme-facebook.md#getting-started).\n\nIf you intend to create a bot that lives inside a Twilio IP Messaging client, [follow these instructions for configuring your app](readme-twilioipm.md#getting-started).\n\nIf you intend to create a bot that uses Microsoft Bot Framework to send and receive messages, [follow these instructions for configuring your app](readme-botframework.md#getting-started).\n\n\n## Install Botkit from NPM or Github\n\nBotkit is available via NPM.\n\n```bash\nnpm install --save botkit\n```\n\nYou can also check out Botkit directly from Git.\nIf you want to use the example code and included bots, it may be preferable to use Github over NPM.\n\n```bash\ngit clone git@github.com:howdyai/botkit.git\n```\n\nAfter cloning the Git repository, you have to install the node dependencies. Navigate to the root of your cloned repository and use npm to install all necessary dependencies.\n```bash\nnpm install\n```\n\nUse the `--production` flag to skip the installation of devDependencies from Botkit. Useful if you just wish to run the example bot.\n```bash\nnpm install --production\n```\n\n\n## Core Concepts\n\nBots built with Botkit have a few key capabilities, which can be used to create clever, conversational applications. These capabilities map to the way real human people talk to each other.\n\nBots can [hear things](#receiving-messages), [say things and reply](#sending-messages) to what they hear.\n\nWith these two building blocks, almost any type of conversation can be created.\n\nTo organize the things a bot says and does into useful units, Botkit bots have a subsystem available for managing [multi-message conversations](#multi-message-replies-to-incoming-messages). Conversations add features like the ability to ask a question, queue several messages at once, and track when an interaction has ended.  Handy!\n\nAfter a bot has been told what to listen for and how to respond,\nit is ready to be connected to a stream of incoming messages. Currently, Botkit supports receiving messages from a variety of sources:\n\n* [Slack Real Time Messaging (RTM)](http://api.slack.com/rtm)\n* [Slack Incoming Webhooks](http://api.slack.com/incoming-webhooks)\n* [Slack Slash Commands](http://api.slack.com/slash-commands)\n* [Facebook Messenger Webhooks](https://developers.facebook.com/docs/messenger-platform/implementation)\n* [Twilio IP Messaging](https://www.twilio.com/user/account/ip-messaging/getting-started)\n* [Microsoft Bot Framework](http://botframework.com/)\n\nRead more about [connecting your bot to Slack](readme-slack.md#connecting-your-bot-to-slack), [connecting your bot to Facebook](readme-facebook.md#getting-started), [connecting your bot to Twilio](readme-twilioipm.md#getting-started),\nor [connecting your bot to Microsoft Bot Framework](readme-botframework.md#getting-started)\n\n## Included Examples\n\nThese examples are included in the Botkit [Github repo](https://github.com/howdyai/botkit).\n\n[slack_bot.js](https://github.com/howdyai/botkit/blob/master/slack_bot.js) An example bot that can be connected to your team. Useful as a basis for creating your first bot!\n\n[facebook_bot.js](https://github.com/howdyai/botkit/blob/master/facebook_bot.js) An example bot that can be connected to your Facebook page. Useful as a basis for creating your first bot!\n\n[twilio_ipm_bot.js](https://github.com/howdyai/botkit/blob/master/twilio_ipm_bot.js) An example bot that can be connected to your Twilio IP Messaging client. Useful as a basis for creating your first bot!\n\n[botframework_bot.js](https://github.com/howdyai/botkit/blob/master/botframework_bot.js) An example bot that can be connected to the Microsoft Bot Framework network. Useful as a basis for creating your first bot!\n\n[examples/demo_bot.js](https://github.com/howdyai/botkit/blob/master/examples/demo_bot.js) another example bot that uses different ways to send and receive messages.\n\n[examples/team_outgoingwebhook.js](https://github.com/howdyai/botkit/blob/master/examples/team_outgoingwebhook.js) an example of a Botkit app that receives and responds to outgoing webhooks from a single team.\n\n[examples/team_slashcommand.js](https://github.com/howdyai/botkit/blob/master/examples/team_slashcommand.js) an example of a Botkit app that receives slash commands from a single team.\n\n[examples/slackbutton_bot.js](https://github.com/howdyai/botkit/blob/master/examples/slackbutton_bot.js) an example of using the Slack Button to offer a bot integration.\n\n[examples/slackbutton_incomingwebhooks.js](https://github.com/howdyai/botkit/blob/master/examples/slackbutton_incomingwebhooks.js) an example of using the Slack Button to offer an incoming webhook integration. This example also includes a simple form which allows you to broadcast a message to any team who adds the integration.\n\n[example/sentiment_analysis.js](https://github.com/howdyai/botkit/blob/master/examples/sentiment_analysis.js) a simple example of a chatbot using sentiment analysis. Keeps a running score of each user based on positive and negative keywords. Messages and thresholds can be configured.\n\n\n## Basic Usage\n\nHere's an example of using Botkit with Slack's [real time API](https://api.slack.com/rtm), which is the coolest one because your bot will look and act like a real user inside Slack.\n\nThis sample bot listens for the word \"hello\" to be said to it -- either as a direct mention (\"@bot hello\") or an indirect mention (\"hello @bot\") or a direct message (a private message inside Slack between the user and the bot).\n\nThe Botkit constructor returns a `controller` object. By attaching event handlers\nto the controller object, developers can specify what their bot should look for and respond to,\nincluding keywords, patterns and various [messaging and status events](#responding-to-events).\nThese event handlers can be thought of metaphorically as skills or features the robot brain has -- each event handler defines a new \"When a human says THIS the bot does THAT.\"\n\nThe `controller` object is then used to `spawn()` bot instances that represent\na specific bot identity and connection to Slack. Once spawned and connected to\nthe API, the bot user will appear online in Slack, and can then be used to\nsend messages and conduct conversations with users. They are called into action by the `controller` when firing event handlers.\n\n```javascript\nvar Botkit = require('botkit');\n\nvar controller = Botkit.slackbot({\n  debug: false\n  //include \"log: false\" to disable logging\n  //or a \"logLevel\" integer from 0 to 7 to adjust logging verbosity\n});\n\n// connect the bot to a stream of messages\ncontroller.spawn({\n  token: <my_slack_bot_token>,\n}).startRTM()\n\n// give the bot something to listen for.\ncontroller.hears('hello',['direct_message','direct_mention','mention'],function(bot,message) {\n\n  bot.reply(message,'Hello yourself.');\n\n});\n\n```\n\n### Botkit Statistics Gathering\n\nAs of version 0.4, Botkit records anonymous usage statistics about Botkit bots in the wild.\nThese statistics are used by the Botkit team at [Howdy](http://howdy.ai) to measure and\nanalyze the Botkit community, and help to direct resources to the appropriate parts of the project.\n\nWe take the privacy of Botkit developers and their users very seriously. Botkit does not collect,\nor transmit any message content, user data, or personally identifiable information to our statistics system.\nThe information that is collected is anonymized inside Botkit and converted using one-way encryption\ninto a hash before being transmitted.\n\n#### Opt Out of Stats\n\nTo opt out of the stats collection, pass in the `stats_optout` parameter when initializing Botkit,\nas seen in the example below:\n\n```\nvar controller = Botkit.slackbot({\n    stats_optout: true\n});\n```\n\n\n# Developing with Botkit\n\nTable of Contents\n\n* [Receiving Messages](#receiving-messages)\n* [Sending Messages](#sending-messages)\n* [Middleware](#middleware)\n* [Advanced Topics](#advanced-topics)\n\n### Responding to events\n\nOnce connected to a messaging platform, bots receive a constant stream of events - everything from the normal messages you would expect to typing notifications and presence change events. The set of events your bot will receive will depend on what messaging platform it is connected to.\n\nAll platforms will receive the `message_received` event. This event is the first event fired for every message of any type received - before any platform specific events are fired.\n\n```javascript\ncontroller.on('message_received', function(bot, message) {\n\n    // carefully examine and\n    // handle the message here!\n    // Note: Platforms such as Slack send many kinds of messages, not all of which contain a text field!\n});\n```\n\nDue to the multi-channel, multi-user nature of Slack, Botkit does additional filtering on the messages (after firing message_received), and will fire more specific events based on the type of message - for example, `direct_message` events indicate a message has been sent directly to the bot, while `direct_mention` indicates that the bot has been mentioned in a multi-user channel.\n[List of Slack-specific Events](readme-slack.md#slack-specific-events)\n\nTwilio IPM bots can also exist in a multi-channel, multi-user environmnet. As a result, there are many additional events that will fire. In addition, Botkit will filter some messages, so that the bot will not receive it's own messages or messages outside of the channels in which it is present.\n[List of Twilio IPM-specific Events](readme-twilioipm.md#twilio-ipm-specific-events)\n\nFacebook messages are fairly straightforward. However, because Facebook supports inline buttons, there is an additional event fired when a user clicks a button.\n[List of Facebook-specific Events](readme-facebook.md#facebook-specific-events)\n\n\n## Receiving Messages\n\nBotkit bots receive messages through a system of specialized event handlers. Handlers can be set up to respond to specific types of messages, or to messages that match a given keyword or pattern.\n\nThese message events can be handled by attaching an event handler to the main controller object.\nThese event handlers take two parameters: the name of the event, and a callback function which is invoked whenever the event occurs.\nThe callback function receives a bot object, which can be used to respond to the message, and a message object.\n\n```javascript\n// reply to any incoming message\ncontroller.on('message_received', function(bot, message) {\n    bot.reply(message, 'I heard... something!');\n});\n\n// reply to a direct mention - @bot hello\ncontroller.on('direct_mention',function(bot,message) {\n  // reply to _message_ by using the _bot_ object\n  bot.reply(message,'I heard you mention me!');\n});\n\n// reply to a direct message\ncontroller.on('direct_message',function(bot,message) {\n  // reply to _message_ by using the _bot_ object\n  bot.reply(message,'You are talking directly to me');\n});\n```\n\n### Matching Patterns and Keywords with `hears()`\n\nIn addition to these traditional event handlers, Botkit also provides the `hears()` function,\nwhich configures event handlers based on matching specific keywords or phrases in the message text.\nThe hears function works just like the other event handlers, but takes a third parameter which\nspecifies the keywords to match.\n\n| Argument | Description\n|--- |---\n| patterns | An _array_ or a _comma separated string_ containing a list of regular expressions to match\n| types  | An _array_ or a _comma separated string_ of the message events in which to look for the patterns\n| middleware function | _optional_ function to redefine how patterns are matched. see [Botkit Middleware](#middleware)\n| callback | callback function that receives a message object\n\n```javascript\ncontroller.hears(['keyword','^pattern$'],['message_received'],function(bot,message) {\n\n  // do something to respond to message\n  bot.reply(message,'You used a keyword!');\n\n});\n```\n\nWhen using the built in regular expression matching, the results of the expression will be stored in the `message.match` field and will match the expected output of normal Javascript `string.match(/pattern/i)`. For example:\n\n```javascript\ncontroller.hears('open the (.*) doors',['message_received'],function(bot,message) {\n  var doorType = message.match[1]; //match[1] is the (.*) group. match[0] is the entire group (open the (.*) doors).\n  if (doorType === 'pod bay') {\n    return bot.reply(message, 'I\\'m sorry, Dave. I\\'m afraid I can\\'t do that.');\n  }\n  return bot.reply(message, 'Okay');\n});\n```\n\n## Sending Messages\n\nBots have to send messages to deliver information and present an interface for their\nfunctionality.  Botkit bots can send messages in several different ways, depending\non the type and number of messages that will be sent.\n\nSingle message replies to incoming commands can be sent using the `bot.reply()` function.\n\nMulti-message replies, particularly those that present questions for the end user to respond to,\ncan be sent using the `bot.startConversation()` function and the related conversation sub-functions.\n\nBots can originate messages - that is, send a message based on some internal logic or external stimulus -\nusing `bot.say()` method.\n\nAll `message` objects must contain a `text` property, even if it's only an empty string.\n\n### Single Message Replies to Incoming Messages\n\nOnce a bot has received a message using a `on()` or `hears()` event handler, a response\ncan be sent using `bot.reply()`.\n\nMessages sent using `bot.reply()` are sent immediately. If multiple messages are sent via\n`bot.reply()` in a single event handler, they will arrive in the  client very quickly\nand may be difficult for the user to process. We recommend using `bot.startConversation()`\nif more than one message needs to be sent.\n\nYou may pass either a string, or a message object to the function.\n\nMessage objects may also contain any additional fields supported by the messaging platform in use:\n\n[Slack's chat.postMessage](https://api.slack.com/methods/chat.postMessage) API accepts several additional fields. These fields can be used to adjust the message appearance, add attachments, or even change the displayed user name.\n\nThis is also true of Facebook. Calls to [Facebook's Send API](https://developers.facebook.com/docs/messenger-platform/send-api-reference) can include attachments which result in interactive \"structured messages\" which can include images, links and action buttons.\n\n#### bot.reply()\n\n| Argument | Description\n|--- |---\n| message | Incoming message object\n| reply | _String_ or _Object_ Outgoing response\n| callback | _Optional_ Callback in the form function(err,response) { ... }\n\nSimple reply example:\n```javascript\ncontroller.hears(['keyword','^pattern$'],['message_received'],function(bot,message) {\n\n  // do something to respond to message\n  // ...\n\n  bot.reply(message,\"Tell me more!\");\n\n});\n```\n\nSlack-specific fields and attachments:\n```javascript\ncontroller.on('ambient',function(bot,message) {\n\n    // do something...\n\n    // then respond with a message object\n    //\n    bot.reply(message,{\n      text: \"A more complex response\",\n      username: \"ReplyBot\",\n      icon_emoji: \":dash:\",\n    });\n\n})\n\n//Using attachments\ncontroller.hears('another_keyword','direct_message,direct_mention',function(bot,message) {\n  var reply_with_attachments = {\n    'username': 'My bot' ,\n    'text': 'This is a pre-text',\n    'attachments': [\n      {\n        'fallback': 'To be useful, I need you to invite me in a channel.',\n        'title': 'How can I help you?',\n        'text': 'To be useful, I need you to invite me in a channel ',\n        'color': '#7CD197'\n      }\n    ],\n    'icon_url': 'http://lorempixel.com/48/48'\n    }\n\n  bot.reply(message, reply_with_attachments);\n});\n\n```\n\n\nFacebook-specific fields and attachments:\n```\n// listen for the phrase `shirt` and reply back with structured messages\n// containing images, links and action buttons\ncontroller.hears(['shirt'],'message_received',function(bot, message) {\n    bot.reply(message, {\n        attachment: {\n            'type':'template',\n            'payload':{\n                 'template_type':'generic',\n                 'elements':[\n                   {\n                     'title':'Classic White T-Shirt',\n                     'image_url':'http://petersapparel.parseapp.com/img/item100-thumb.png',\n                     'subtitle':'Soft white cotton t-shirt is back in style',\n                     'buttons':[\n                       {\n                         'type':'web_url',\n                         'url':'https://petersapparel.parseapp.com/view_item?item_id=100',\n                         'title':'View Item'\n                       },\n                       {\n                         'type':'web_url',\n                         'url':'https://petersapparel.parseapp.com/buy_item?item_id=100',\n                         'title':'Buy Item'\n                       },\n                       {\n                         'type':'postback',\n                         'title':'Bookmark Item',\n                         'payload':'USER_DEFINED_PAYLOAD_FOR_ITEM100'\n                       }\n                     ]\n                   },\n                   {\n                     'title':'Classic Grey T-Shirt',\n                     'image_url':'http://petersapparel.parseapp.com/img/item101-thumb.png',\n                     'subtitle':'Soft gray cotton t-shirt is back in style',\n                     'buttons':[\n                       {\n                         'type':'web_url',\n                         'url':'https://petersapparel.parseapp.com/view_item?item_id=101',\n                         'title':'View Item'\n                       },\n                       {\n                         'type':'web_url',\n                         'url':'https://petersapparel.parseapp.com/buy_item?item_id=101',\n                         'title':'Buy Item'\n                       },\n                       {\n                         'type':'postback',\n                         'title':'Bookmark Item',\n                         'payload':'USER_DEFINED_PAYLOAD_FOR_ITEM101'\n                       }\n                     ]\n                   }\n                 ]\n               }\n        }\n    });\n});\n```\n\n### Multi-message Replies to Incoming Messages\n\nFor more complex commands, multiple messages may be necessary to send a response,\nparticularly if the bot needs to collect additional information from the user.\n\nBotkit provides a `Conversation` object type that is used to string together several\nmessages, including questions for the user, into a cohesive unit. Botkit conversations\nprovide useful methods that enable developers to craft complex conversational\nuser interfaces that may span a several minutes of dialog with a user, without having to manage\nthe complexity of connecting multiple incoming and outgoing messages across\nmultiple API calls into a single function.\n\nMessages sent as part of a conversation are sent no faster than one message per second,\nwhich roughly simulates the time it would take for the bot to \"type\" the message.\n\n### Start a Conversation\n\n#### bot.startConversation()\n| Argument | Description\n|---  |---\n| message   | incoming message to which the conversation is in response\n| callback  | a callback function in the form of  function(err,conversation) { ... }\n\n`startConversation()` is a function that creates conversation in response to an incoming message.\nThe conversation will occur _in the same channel_ in which the incoming message was received.\nOnly the user who sent the original incoming message will be able to respond to messages in the conversation.\n\n#### bot.startPrivateConversation()\n| Argument | Description\n|---  |---\n| message   | message object containing {user: userId} of the user you would like to start a conversation with\n| callback  | a callback function in the form of  function(err,conversation) { ... }\n\n`startPrivateConversation()` is a function that initiates a conversation with a specific user. Note function is currently *Slack-only!*\n\n#### bot.createConversation()\n| Argument | Description\n|---  |---\n| message   | incoming message to which the conversation is in response\n| callback  | a callback function in the form of  function(err,conversation) { ... }\n\nThis works just like `startConversation()`, with one main difference - the conversation\nobject passed into the callback will be in a dormant state. No messages will be sent,\nand the conversation will not collect responses until it is activated using [convo.activate()](#conversationactivate).\n\nUse `createConversation()` instead of `startConversation()` when you plan on creating more complex conversation structures using [threads](#conversation-threads) or [variables and templates](#using-variable-tokens-and-templates-in-conversation-threads) in your messages.\n\n### Control Conversation Flow\n\n#### conversation.activate()\n\nThis function will cause a dormant conversation created with [bot.createConversation()](#botcreateconversation) to be activated, which will cause it to start sending messages and receiving replies from end users.\n\nA conversation can be kept dormant in order to preload it with [variables](#using-variable-tokens-and-templates-in-conversation-threads), particularly data that requires asynchronous actions to take place such as loading data from a database or remote source.  You may also keep a conversation inactive while you build threads, setting it in motion only when all of the user paths have been defined.\n\n#### conversation.say()\n| Argument | Description\n|---  |---\n| message   | String or message object\n\nCall convo.say() several times in a row to queue messages inside the conversation. Only one message will be sent at a time, in the order they are queued.\n\n```javascript\ncontroller.hears(['hello world'], 'message_received', function(bot,message) {\n\n  // start a conversation to handle this response.\n  bot.startConversation(message,function(err,convo) {\n\n    convo.say('Hello!');\n    convo.say('Have a nice day!');\n\n  });\n});\n```\n\n#### conversation.ask()\n| Argument | Description\n|---  |---\n| message   | String or message object containing the question\n| callback _or_ array of callbacks   | callback function in the form function(response_message,conversation), or array of objects in the form ``{ pattern: regular_expression, callback: function(response_message,conversation) { ... } }``\n| capture_options | _Optional_ Object defining options for capturing the response\n\nWhen passed a callback function, conversation.ask will execute the callback function for any response.\nThis allows the bot to respond to open ended questions, collect the responses, and handle them in whatever\nmanner it needs to.\n\nWhen passed an array, the bot will look first for a matching pattern, and execute only the callback whose\npattern is matched. This allows the bot to present multiple choice options, or to proceed\nonly when a valid response has been received. At least one of the patterns in the array must be marked as the default option,\nwhich will be called should no other option match. Botkit comes pre-built with several useful patterns which can be used with this function. See [included utterances](#included-utterances)\n\nCallback functions passed to `ask()` receive two parameters - the first is a standard message object containing\nthe user's response to the question. The second is a reference to the conversation itself.\n\nNote that in order to continue the conversation, `convo.next()` must be called by the callback function. This\nfunction tells Botkit to continue processing the conversation. If it is not called, the conversation will hang\nand never complete causing memory leaks and instability of your bot application!\n\nThe optional third parameter `capture_options` can be used to define different behaviors for collecting the user's response.\nThis object can contain the following fields:\n\n| Field | Description\n|--- |---\n| key | _String_ If set, the response will be stored and can be referenced using this key\n| multiple | _Boolean_ if true, support multi-line responses from the user (allow the user to respond several times and aggregate the response into a single multi-line value)\n\n##### Using conversation.ask with a callback:\n\n```javascript\ncontroller.hears(['question me'], 'message_received', function(bot,message) {\n\n  // start a conversation to handle this response.\n  bot.startConversation(message,function(err,convo) {\n\n    convo.ask('How are you?',function(response,convo) {\n\n      convo.say('Cool, you said: ' + response.text);\n      convo.next();\n\n    });\n\n  })\n\n});\n```\n\n##### Using conversation.ask with an array of callbacks:\n\n```javascript\ncontroller.hears(['question me'], 'message_received', function(bot,message) {\n\n  // start a conversation to handle this response.\n  bot.startConversation(message,function(err,convo) {\n\n    convo.ask('Shall we proceed Say YES, NO or DONE to quit.',[\n      {\n        pattern: 'done',\n        callback: function(response,convo) {\n          convo.say('OK you are done!');\n          convo.next();\n        }\n      },\n      {\n        pattern: bot.utterances.yes,\n        callback: function(response,convo) {\n          convo.say('Great! I will continue...');\n          // do something else...\n          convo.next();\n\n        }\n      },\n      {\n        pattern: bot.utterances.no,\n        callback: function(response,convo) {\n          convo.say('Perhaps later.');\n          // do something else...\n          convo.next();\n        }\n      },\n      {\n        default: true,\n        callback: function(response,convo) {\n          // just repeat the question\n          convo.repeat();\n          convo.next();\n        }\n      }\n    ]);\n\n  })\n\n});\n```\n\n### Conversation Threads\n\nWhile conversations with only a few questions can be managed by writing callback functions,\nmore complex conversations that require branching, repeating or looping sections of dialog,\nor data validation can be handled using feature of the conversations we call `threads`.\n\nThreads are pre-built chains of dialog between the bot and end user that are built before the conversation begins. Once threads are built, Botkit can be instructed to navigate through the threads automatically, allowing many common programming scenarios such as yes/no/quit prompts to be handled without additional code.\n\nYou can build conversation threads in code, or you can use [Botkit Studio](/readme-studio.md)'s script management tool to build them in a friendly web environment. Conversations you build yourself and conversations managed in Botkit Studio work the same way -- they run inside your bot and use your code to manage the outcome.\n\nIf you've used the conversation system at all, you've used threads - you just didn't know it. When calling `convo.say()` and `convo.ask()`, you were actually adding messages to the `default` conversation thread that is activated when the conversation object is created.\n\n\n#### convo.addMessage\n| Argument | Description\n|---  |---\n| message   | String or message object\n| thread_name   | String defining the name of a thread\n\nThis function works identically to `convo.say()` except that it takes a second parameter which defines the thread to which the message will be added rather than being queued to send immediately, as is the case when using convo.say().\n\n#### convo.addQuestion\n| Argument | Description\n|---  |---\n| message   | String or message object containing the question\n| callback _or_ array of callbacks   | callback function in the form function(response_message,conversation), or array of objects in the form ``{ pattern: regular_expression, callback: function(response_message,conversation) { ... } }``\n| capture_options |  Object defining options for capturing the response. Pass an empty object if capture options are not needed\n| thread_name   | String defining the name of a thread\n\nThis function works identically to `convo.ask()` except that it takes second parameter which defines the thread to which the message will be added rather than being queued to send immediately, as is the case when using convo.ask().\n\n\n#### convo.gotoThread\n| Argument | Description\n|---  |---\n| thread_name   | String defining the name of a thread\n\nCause the bot to immediately jump to the named thread.\nAll conversations start in a thread called `default`, but you may switch to another existing thread before the conversation has been activated, or in a question callback.\n\nThreads are created by adding messages to them using `addMessage()` and `addQuestion()`\n\n```\n// create the validation_error thread\nconvo.addMessage('This is a validation error.', 'validation_error');\nconvo.addMessage('I am sorry, your data is wrong!', 'validation_error');\n\n// switch to the validation thread immediately\nconvo.gotoThread('validation_error');\n```\n\n\n#### convo.transitionTo\n| Argument | Description\n|---  |---\n| thread_name   | String defining the name of a thread\n| message   | String or message object\n\nLike `gotoThread()`, jumps to the named thread. However, before doing so,\nBotkit will first send `message` to the user as a transition. This allows\ndevelopers to specify dynamic transition messages to improve the flow of the\nconversation.\n\n```javascript\n// create an end state thread\ncovo.addMessage('This is the end!', 'the_end');\n\n// now transition there with a nice message\nconvo.transitionTo('the_end','Well I think I am all done.');\n```\n\n#### Automatically Switch Threads using Actions\n\nYou can direct a conversation to switch from one thread to another automatically\nby including the `action` field on a message object. Botkit will switch threads immediately after sending the message.\n\n```\n// first, define a thread called `next_step` that we'll route to...\nconvo.addMessage({\n    text: 'This is the next step...',\n},'next_step');\n\n\n// send a message, and tell botkit to immediately go to the next_step thread\nconvo.addMessage({\n    text: 'Anyways, moving on...',\n    action: 'next_step'\n});\n```\n\nDevelopers can create fairly complex conversational systems by combining these message actions with conditionals in `ask()` and `addQuestion()`.  Actions can be used to specify\ndefault or next step actions, while conditionals can be used to route between threads.\n\nFrom inside a callback function, use `convo.gotoThread()` to instantly switch to a different pre-defined part of the conversation. Botkit can be set to automatically navigate between threads based on user input, such as in the example below.\n\n```\nbot.createConversation(message, function(err, convo) {\n\n    // create a path for when a user says YES\n    convo.addMessage({\n            text: 'You said yes! How wonderful.',\n    },'yes_thread');\n\n    // create a path for when a user says NO\n    convo.addMessage({\n        text: 'You said no, that is too bad.',\n    },'no_thread');\n\n    // create a path where neither option was matched\n    // this message has an action field, which directs botkit to go back to the `default` thread after sending this message.\n    convo.addMessage({\n        text: 'Sorry I did not understand.',\n        action: 'default',\n    },'bad_response');\n\n    // Create a yes/no question in the default thread...\n    convo.ask('Do you like cheese?', [\n        {\n            pattern: 'yes',\n            callback: function(response, convo) {\n                convo.changeTopic('yes_thread');\n            },\n        },\n        {\n            pattern: 'no',\n            callback: function(response, convo) {\n                convo.changeTopic('no_thread');\n            },\n        },\n        {\n            default: true,\n            callback: function(response, convo) {\n                convo.changeTopic('bad_response');\n            },\n        }\n    ]);\n\n    convo.activate();\n});\n```\n\n#### Special Actions\n\nIn addition to routing from one thread to another using actions, you can also use\none of a few reserved words to control the conversation flow.\n\nSet the action field of a message to `completed` to end the conversation immediately and mark as success.\n\nSet the action field of a message to `stop` end immediately, but mark as failed.\n\nSet the action field of a message to `timeout` to end immediately and indicate that the conversation has timed out.\n\nAfter the conversation ends, these values will be available in the `convo.status` field. This field can then be used to check the final outcome of a conversation. See [handling the end of conversations](#handling-the-end-of-conversation).\n\n### Using Variable Tokens and Templates in Conversation Threads\n\nPre-defined conversation threads are great, but many times developers will need to inject dynamic content into a conversation.\nBotkit achieves this by processing the text of every message using the [Mustache template language](https://mustache.github.io/).\nMustache offers token replacement, as well as access to basic iterators and conditionals.\n\nVariables can be added to a conversation at any point after the conversation object has been created using the function `convo.setVar()`. See the example below.\n\n```\nconvo.createConversation(message, function(err, convo) {\n\n    // .. define threads which will use variables...\n    // .. and then, set variable values:\n    convo.setVar('foo','bar');\n    convo.setVar('list',[{value:'option 1'},{value:'option 2'}]);\n    convo.setVar('object',{'name': 'Chester', 'type': 'imaginary'});\n\n    // now set the conversation in motion...\n    convo.activate();\n});\n```\n\nGiven the variables defined in this code sample, `foo`, a simple string, `list`, an array, and `object`, a JSON-style object,\nthe following Mustache tokens and patterns would be available:\n\n```\nThe value of foo is {{vars.foo}}\n\nThe items in this list include {{#vars.list}}{{value}}{{/vars.list}}\n\nThe object's name is {{vars.object.name}}.\n\n{{#foo}}If foo is set, I will say this{{/foo}}{{^foo}}If foo is not set, I will say this other thing.{{/foo}}\n```\nBotkit ensures that your template is a valid Mustache template, and passes the variables you specify directly to the Mustache template rendering system.\nOur philosophy is that it is OK to stuff whatever type of information your conversation needs into these variables and use them as you please!\n\n#### convo.setVar\n| Argument | Description\n|---  |---\n| variable_name   | The name of a variable to be made available to message text templates.\n| value | The value of the variable, which can be any type of normal Javascript variable\n\nCreate or update a variable that is available as a Mustache template token to all the messages in all the threads contained in the conversation.\n\nThe variable will be available in the template as `{{vars.variable_name}}`\n\n#### Built-in Variables\n\nBotkit provides several built in variables that are automatically available to all messages:\n\n{{origin}} - a message object that represents the initial triggering message that caused the conversation.\n\n{{responses}} - an object that contains all of the responses a user has given during the course of the conversation. This can be used to make references to previous responses. This requires that `convo.ask()` questions include a keyname, making responses available at `{{responses.keyname}}`\n\n##### Multi-stage conversations\n\n![multi-stage convo example](https://www.evernote.com/shard/s321/sh/7243cadf-be40-49cf-bfa2-b0f524176a65/f9257e2ff5ee6869/res/bc778282-64a5-429c-9f45-ea318c729225/screenshot.png?resizeSmall&width=832)\n\nOne way to have multi-stage conversations is with multiple functions\nwhich call each other. Each function asks just one question. Example:\n\n```javascript\ncontroller.hears(['pizzatime'], 'message_received', function(bot,message) {\n    var askFlavor = function(err, convo) {\n      convo.ask('What flavor of pizza do you want?', function(response, convo) {\n        convo.say('Awesome.');\n        askSize(response, convo);\n        convo.next();\n      });\n    };\n    var askSize = function(response, convo) {\n      convo.ask('What size do you want?', function(response, convo) {\n        convo.say('Ok.')\n        askWhereDeliver(response, convo);\n        convo.next();\n      });\n    };\n    var askWhereDeliver = function(response, convo) {\n      convo.ask('So where do you want it delivered?', function(response, convo) {\n        convo.say('Ok! Good bye.');\n        convo.next();\n      });\n    };\n\n    bot.startConversation(message, askFlavor);\n});\n```\n\nThe full code for this example can be found in ```examples/convo_bot.js```.\n\n##### Included Utterances\n\n| Pattern Name | Description\n|--- |---\n| bot.utterances.yes | Matches phrases like yes, yeah, yup, ok and sure.\n| bot.utterances.no | Matches phrases like no, nah, nope\n\n##### Conversation Control Functions\n\nIn order to direct the flow of the conversation, several helper functions\nare provided.  These functions should only be called from within a convo.ask\nhandler function!\n\n`convo.sayFirst(message)` Works just like convo.say, but injects a message into the first spot in the queue\nso that it is sent immediately, before any other queued messages.\n\n`convo.stop()` end the conversation immediately, and set convo.status to `stopped`\n\n`convo.repeat()` repeat the last question sent and continue to wait for a response.\n\n`convo.silentRepeat()` simply wait for another response without saying anything.\n\n`convo.next()` proceed to the next message in the conversation.  *This must be called* at the end of each handler.\n\n### Handling End of Conversation\n\nConversations trigger events during the course of their life.  Currently,\nonly two events are fired, and only one is very useful: end.\n\nConversations end naturally when the last message has been sent and no messages remain in the queue.\nIn this case, the value of `convo.status` will be `completed`. Other values for this field include `active`, `stopped`, and `timeout`.\n\n```javascript\nconvo.on('end',function(convo) {\n\n  if (convo.status=='completed') {\n    // do something useful with the users responses\n    var res = convo.extractResponses();\n\n    // reference a specific response by key\n    var value  = convo.extractResponse('key');\n\n    // ... do more stuff...\n\n  } else {\n    // something happened that caused the conversation to stop prematurely\n  }\n\n});\n```\n\n#### convo.extractResponses()\n\nReturns an object containing all of the responses a user sent during the course of a conversation.\n\n```javascript\nvar values = convo.extractResponses();\nvar value = values.key;\n```\n\n#### convo.extractResponse()\n\nReturn one specific user response, identified by its key.\n\n```javascript\nvar value  = convo.extractResponse('key');\n```\n\n### Originating Messages\n\n#### bot.say()\n| Argument | Description\n|--- |---\n| message | A message object\n| callback | _Optional_ Callback in the form function(err,response) { ... }\n\nSlack-specific Example:\n```javascript\nbot.say(\n  {\n    text: 'my message text',\n    channel: 'C0H338YH4' // a valid slack channel, group, mpim, or im ID\n  }\n);\n```\nNote: If your primary need is to spontaneously send messages rather than respond to incoming messages, you may want to use [Slack's incoming webhooks feature](readme-slack.md#incoming-webhooks) rather than the real time API.\n\n\nFacebook-specific Example:\n```javascript\nbot.say(\n    {\n        text: 'my message_text',\n        channel: '+1(###)###-####' // a valid facebook user id or phone number\n    }\n);\n```\n\n## Middleware\n\nThe functionality of Botkit can be extended using middleware\nfunctions. These functions can plugin to the core bot running processes at\nseveral useful places and make changes to both a bot's configuration and\nthe incoming or outgoing message.\n\nFor information about existing middleware plugins, [see here](readme-middlewares.md)\n\n### Middleware Endpoints\n\nBotkit currently supports middleware insertion in three places:\n\n* When receiving a message, before triggering any events\n* When sending a message, before the message is sent to the API\n* When hearing a message\n\nSend and Receive middleware functions are added to Botkit using an Express-style \"use\" syntax.\nEach function receives a bot parameter, a message parameter, and\na next function which must be called to continue processing the middleware stack.\n\nHear middleware functions are passed in to the `controller.hears` function,\nand override the built in regular expression matching.\n\n### Receive Middleware\n\nReceive middleware can be used to do things like preprocess the message\ncontent using external natural language processing services like Wit.ai.\nAdditional information can be added to the message object for use down the chain.\n\n```\ncontroller.middleware.receive.use(function(bot, message, next) {\n\n    // do something...\n    // message.extrainfo = 'foo';\n    next();\n\n});\n```\n\n\n### Send Middleware\n\nSend middleware can be used to do things like preprocess the message\ncontent before it gets sent out to the messaging client.\n\n```\ncontroller.middleware.send.use(function(bot, message, next) {\n\n    // do something useful...\n    if (message.intent == 'hi') {\n        message.text = 'Hello!!!';\n    }\n    next();\n\n});\n```\n\n\n### Hear Middleware\n\nHear middleware can be used to change the way Botkit bots \"hear\" triggers.\nIt can be used to look for values in fields other than message.text, or use comparison methods other than regular expression matching. For example, a middleware function\ncould enable Botkit to \"hear\" intents added by an NLP classifier instead of string patterns.\n\nHear middleware is enabled by passing a function into the `hears()` method on the Botkit controller.\nWhen specified, the middleware function will be used instead of the built in regular expression match.\n\nThese functions receive 2 parameters - `patterns` an array of patterns, and `message` the incoming\nmessage. This function will be called _after_ any receive middlewares, so may use any additional\ninformation that may have been added. A return value of `true` indicates the pattern has been\nmatched and the bot should respond.\n\n```\n// this example does a simple string match instead of using regular expressions\nfunction custom_hear_middleware(patterns, message) {\n\n    for (var p = 0; p < patterns.length; p++) {\n        if (patterns[p] == message.text) {\n            return true;\n        }\n    }\n    return false;\n}\n\n\ncontroller.hears(['hello'],'direct_message',custom_hear_middleware,function(bot, message) {\n\n    bot.reply(message, 'I heard the EXACT string match for \"hello\"');\n\n});\n```\n\nIt is possible to completely replace the built in regular expression match with\na middleware function by calling `controller.changeEars()`. This will replace the matching function used in `hears()`\nas well as inside `convo.ask().` This would, for example, enable your bot to\nhear only intents instead of strings.\n\n```\ncontroller.changeEars(function(patterns, message) {\n\n    // ... do something\n    // return true or false\n});\n```\n\n# Advanced Topics\n\n\n## Storing Information\n\nBotkit has a built in storage system used to keep data on behalf of users and teams between sessions. Botkit uses this system automatically when storing information for Slack Button applications (see below).\n\nBy default, Botkit will use [json-file-store](https://github.com/flosse/json-file-store) to keep data in JSON files in the filesystem of the computer where the bot is executed. (Note this will not work on Heroku or other hosting systems that do not let node applications write to the file system.) Initialize this system when you create the bot:\n```javascript\nvar controller = Botkit.slackbot({\n  json_file_store: 'path_to_json_database'\n});\n```\n\nThis system supports freeform storage on a team-by-team, user-by-user, and channel-by-channel basis. Basically ```controller.storage``` is a key value store. All access to this system is through the following nine functions. Example usage:\n```javascript\ncontroller.storage.users.save({id: message.user, foo:'bar'}, function(err) { ... });\ncontroller.storage.users.get(id, function(err, user_data) {...});\ncontroller.storage.users.delete(id, function(err) {...});\ncontroller.storage.users.all(function(err, all_user_data) {...});\n\ncontroller.storage.channels.save({id: message.channel, foo:'bar'}, function(err) { ... });\ncontroller.storage.channels.get(id, function(err, channel_data) {...});\ncontroller.storage.channels.delete(id, function(err) {...});\ncontroller.storage.channels.all(function(err, all_channel_data) {...});\n\ncontroller.storage.teams.save({id: message.team, foo:'bar'}, function(err) { ... });\ncontroller.storage.teams.get(id, function(err, team_data) {...});\ncontroller.storage.teams.delete(id, function(err) {...});\ncontroller.storage.teams.all(function(err, all_team_data) {...});\n```\n\nNote that save must be passed an object with an id. It is recommended to use the team/user/channel id for this purpose.\n```[user/channel/team]_data``` will always be an object while ```all_[user/channel/team]_data``` will always be a list of objects.\n\n### Writing your own storage module\n\nIf you want to use a database or do something else with your data,\nyou can write your own storage module and pass it in.\n\nMake sure your module returns an object with all the methods. See [simple_storage.js](https://github.com/howdyai/botkit/blob/master/lib/storage/simple_storage.js) for an example of how it is done!\nMake sure your module passes the test in [storage_test.js](https://github.com/howdyai/botkit/blob/master/lib/storage/storage_test.js).\n\nThen, use it when you create your bot:\n```javascript\nvar controller = Botkit.slackbot({\n  storage: my_storage_provider\n})\n```\n\n### Writing your own logging module\n\nBy default, your bot will log to the standard JavaScript `console` object\navailable in Node.js. This will synchronously print logging messages to stdout\nof the running process.\n\nThere may be some cases, such as remote debugging or rotating of large logs,\nwhere you may want a more sophisticated logging solution. You can write your\nown logging module that uses a third-party tool, like\n[winston](https://github.com/winstonjs/winston) or\n[Bristol](https://github.com/TomFrost/Bristol). Just create an object with a\n`log` method. That method should take a severity level (such as `'error'` or\n`'debug'`) as its first argument, and then any number of other arguments that\nwill be logged as messages. (Both Winston and Bristol create objects of this\ndescription; it's a common interface.)\n\nThen, use it when you create your bot:\n```javascript\nvar controller = Botkit.slackbot({\n  logger: new winston.Logger({\n    levels: winston.config.syslog.levels\n    transports: [\n      new (winston.transports.Console)(),\n      new (winston.transports.File)({ filename: './bot.log' })\n    ]\n  })\n});\n```\n\nNote: with Winston, we must use the syslog.levels over the default or else some botkit log messages (like 'notice') will not be logged properly.  \n\n##Use Botkit with an Express web server\nInstead of controller.setupWebserver(), it is possible to use a different web server to manage authentication flows, as well as serving web pages.\n\nHere is an example of [using an Express web server alongside Botkit](https://github.com/mvaragnat/botkit-express-demo).\n\n# Chat with us at dev4slack.slack.com\nYou can get an invite here: http://dev4slack.xoxco.com/.\n",
  "readmeFilename": "readme.md",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/howdyai/botkit.git"
  },
  "scripts": {
    "pretest": "jscs ./lib/",
    "test": "mocha tests/*.js"
  },
  "version": "0.4.6"
}
